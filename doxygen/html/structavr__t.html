<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>SimAVR: avr_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimAVR
   </div>
   <div id="projectbrief">AVR Simulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structavr__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">avr_t Struct Reference<div class="ingroups"><a class="el" href="group__sim__avr.html">AVR Simulation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Main AVR instance.  
 <a href="structavr__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sim__avr_8h_source.html">sim_avr.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for avr_t:</div>
<div class="dyncontent">
<div class="center"><img src="structavr__t__coll__graph.png" border="0" usemap="#avr__t_coll__map" alt="Collaboration graph"/></div>
<map name="avr__t_coll__map" id="avr__t_coll__map">
<area shape="rect" id="node3" href="structavr__cycle__timer__slot__t.html" title="Each timer instance contains the absolute cycle number they are hoping to run at, a function pointer ..." alt="" coords="912,215,1065,241"/><area shape="rect" id="node4" href="structavr__io__t.html" title="IO module base struct Modules uses that as their first member in their own struct. " alt="" coords="955,304,1023,331"/><area shape="rect" id="node13" href="structavr__vcd__t.html" title="avr_vcd_t" alt="" coords="949,88,1028,115"/><area shape="rect" id="node16" href="structavr__gdb__t.html" title="avr_gdb_t" alt="" coords="949,436,1028,463"/><area shape="rect" id="node2" href="structavr__cycle__timer__pool__t.html" title="Timer pool contains a pool of timer slots available, they all start queued into the &#39;free&#39; qeueue..." alt="" coords="1179,311,1335,337"/><area shape="rect" id="node5" href="structavr__irq__t.html" title="Public IRQ structure. " alt="" coords="15,199,87,225"/><area shape="rect" id="node6" href="structavr__irq__pool__t.html" title="IRQ Pool structure. " alt="" coords="193,176,295,203"/><area shape="rect" id="node7" href="structavr__irq__hook__t.html" title="avr_irq_hook_t" alt="" coords="191,267,297,293"/><area shape="rect" id="node11" href="structavr__int__vector__t.html" title="interrupt vector for the IO modules " alt="" coords="187,320,301,347"/><area shape="rect" id="node14" href="structavr__vcd__signal__t.html" title="This structure registers IRQ change hooks to various &quot;source&quot; IRQs and dumps their values (if changed..." alt="" coords="403,35,523,61"/><area shape="rect" id="node8" href="structavr__trace__data__t.html" title="This is only ever used if CONFIG_SIMAVR_TRACE is defined. " alt="" coords="403,421,522,448"/><area shape="rect" id="node9" href="structavr__symbol__t.html" title="Symbol loaded from the .elf file. " alt="" coords="194,421,294,448"/><area shape="rect" id="node10" href="structavr__int__table__t.html" title="Interrupt vectors, and their enable/clear registers. " alt="" coords="409,315,516,341"/><area shape="rect" id="node12" href="structavr__regbit__t.html" title="This &#39;structure&#39; is a packed representation of an IO register &#39;bit&#39; (or consecutive bits)..." alt="" coords="5,420,96,447"/><area shape="rect" id="node15" href="structavr__vcd__log__t.html" title="avr_vcd_log_t" alt="" coords="663,45,765,72"/><area shape="rect" id="node17" href="structavr__gdb__watchpoints__t.html" title="avr_gdb_watchpoints_t" alt="" coords="636,496,792,523"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab64a3ef25ab524ce24d8a522759946da"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#ab64a3ef25ab524ce24d8a522759946da">mmcu</a></td></tr>
<tr class="memdesc:ab64a3ef25ab524ce24d8a522759946da"><td class="mdescLeft">&#160;</td><td class="mdescRight">name of the AVR  <a href="#ab64a3ef25ab524ce24d8a522759946da">More...</a><br /></td></tr>
<tr class="separator:ab64a3ef25ab524ce24d8a522759946da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a4791269dfe22d393f282e523e8742"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a87a4791269dfe22d393f282e523e8742">ramend</a></td></tr>
<tr class="separator:a87a4791269dfe22d393f282e523e8742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea10c774417c9658250256327874273"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a3ea10c774417c9658250256327874273">flashend</a></td></tr>
<tr class="separator:a3ea10c774417c9658250256327874273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa39ad552c1ecaedab1c682a46bd060"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a0aa39ad552c1ecaedab1c682a46bd060">e2end</a></td></tr>
<tr class="separator:a0aa39ad552c1ecaedab1c682a46bd060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bdc8c5972b025d3ad733df81f3167d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a62bdc8c5972b025d3ad733df81f3167d">vector_size</a></td></tr>
<tr class="separator:a62bdc8c5972b025d3ad733df81f3167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28beecf564ea81ebea2eee4f6c97ad93"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a28beecf564ea81ebea2eee4f6c97ad93">signature</a> [3]</td></tr>
<tr class="separator:a28beecf564ea81ebea2eee4f6c97ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a6852737616d49536eb37c388d5c3a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a18a6852737616d49536eb37c388d5c3a">fuse</a> [4]</td></tr>
<tr class="separator:a18a6852737616d49536eb37c388d5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14704e421137047a3df0676ef7fabb36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr__types.html#ga3b13b10386fba02e9279995b1a7e103f">avr_io_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a14704e421137047a3df0676ef7fabb36">rampz</a></td></tr>
<tr class="memdesc:a14704e421137047a3df0676ef7fabb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional, only for ELPM/SPM on &gt;64Kb cores  <a href="#a14704e421137047a3df0676ef7fabb36">More...</a><br /></td></tr>
<tr class="separator:a14704e421137047a3df0676ef7fabb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fce2154767008ee2a6f9494b9e53b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr__types.html#ga3b13b10386fba02e9279995b1a7e103f">avr_io_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a6fce2154767008ee2a6f9494b9e53b87">eind</a></td></tr>
<tr class="memdesc:a6fce2154767008ee2a6f9494b9e53b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional, only for EIJMP/EICALL on &gt;64Kb cores  <a href="#a6fce2154767008ee2a6f9494b9e53b87">More...</a><br /></td></tr>
<tr class="separator:a6fce2154767008ee2a6f9494b9e53b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95d9fb3a2bf2c9e7c08fce4321e3c0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#adf95d9fb3a2bf2c9e7c08fce4321e3c0">address_size</a></td></tr>
<tr class="memdesc:adf95d9fb3a2bf2c9e7c08fce4321e3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">2, or 3 for cores &gt;128KB in flash  <a href="#adf95d9fb3a2bf2c9e7c08fce4321e3c0">More...</a><br /></td></tr>
<tr class="separator:adf95d9fb3a2bf2c9e7c08fce4321e3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e53f0a463305b7b6ef22813a60bcf98"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a2e53f0a463305b7b6ef22813a60bcf98">codeend</a></td></tr>
<tr class="memdesc:a2e53f0a463305b7b6ef22813a60bcf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">filled by the ELF data, this allow tracking of invalid jumps  <a href="#a2e53f0a463305b7b6ef22813a60bcf98">More...</a><br /></td></tr>
<tr class="separator:a2e53f0a463305b7b6ef22813a60bcf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f234133d3efe315836311cbf21c64b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a89f234133d3efe315836311cbf21c64b">state</a></td></tr>
<tr class="memdesc:a89f234133d3efe315836311cbf21c64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">stopped, running, sleeping  <a href="#a89f234133d3efe315836311cbf21c64b">More...</a><br /></td></tr>
<tr class="separator:a89f234133d3efe315836311cbf21c64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab632fb0b4d5156ea4df0b1e15410e913"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#ab632fb0b4d5156ea4df0b1e15410e913">frequency</a></td></tr>
<tr class="memdesc:ab632fb0b4d5156ea4df0b1e15410e913"><td class="mdescLeft">&#160;</td><td class="mdescRight">frequency we are running at  <a href="#ab632fb0b4d5156ea4df0b1e15410e913">More...</a><br /></td></tr>
<tr class="separator:ab632fb0b4d5156ea4df0b1e15410e913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cfa22b2140b109fe24b97c42d5a5ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a35cfa22b2140b109fe24b97c42d5a5ed">vcc</a></td></tr>
<tr class="separator:a35cfa22b2140b109fe24b97c42d5a5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be3f1be5552951cd6c9d8215216e220"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a5be3f1be5552951cd6c9d8215216e220">avcc</a></td></tr>
<tr class="separator:a5be3f1be5552951cd6c9d8215216e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb62932b1bf8d286a3df060f408ddf0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#adeb62932b1bf8d286a3df060f408ddf0">aref</a></td></tr>
<tr class="memdesc:adeb62932b1bf8d286a3df060f408ddf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(optional) voltages in millivolts  <a href="#adeb62932b1bf8d286a3df060f408ddf0">More...</a><br /></td></tr>
<tr class="separator:adeb62932b1bf8d286a3df060f408ddf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50999c398e8eb00dcc9356cbe97dd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#aa50999c398e8eb00dcc9356cbe97dd35">cycle</a></td></tr>
<tr class="memdesc:aa50999c398e8eb00dcc9356cbe97dd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">current cycle  <a href="#aa50999c398e8eb00dcc9356cbe97dd35">More...</a><br /></td></tr>
<tr class="separator:aa50999c398e8eb00dcc9356cbe97dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2defa34e1d57649feca9e277570adc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#ac2defa34e1d57649feca9e277570adc6">run_cycle_count</a></td></tr>
<tr class="memdesc:ac2defa34e1d57649feca9e277570adc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">cycles to run before next timer  <a href="#ac2defa34e1d57649feca9e277570adc6">More...</a><br /></td></tr>
<tr class="separator:ac2defa34e1d57649feca9e277570adc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b68f6669dd3b7e33dc365cfae5f100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a50b68f6669dd3b7e33dc365cfae5f100">run_cycle_limit</a></td></tr>
<tr class="memdesc:a50b68f6669dd3b7e33dc365cfae5f100"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum run cycle interval limit  <a href="#a50b68f6669dd3b7e33dc365cfae5f100">More...</a><br /></td></tr>
<tr class="separator:a50b68f6669dd3b7e33dc365cfae5f100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eee3ccdb7463c4aaa6fa3e53fa40c29"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a2eee3ccdb7463c4aaa6fa3e53fa40c29">sleep_usec</a></td></tr>
<tr class="memdesc:a2eee3ccdb7463c4aaa6fa3e53fa40c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep requests are accumulated in sleep_usec until the minimum sleep value is reached, at which point sleep_usec is cleared and the sleep request is passed on to the operating system.  <a href="#a2eee3ccdb7463c4aaa6fa3e53fa40c29">More...</a><br /></td></tr>
<tr class="separator:a2eee3ccdb7463c4aaa6fa3e53fa40c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecac2eda8f41ca90e6db587e3ce40a0d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#aecac2eda8f41ca90e6db587e3ce40a0d">init</a> )(struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>)</td></tr>
<tr class="memdesc:aecac2eda8f41ca90e6db587e3ce40a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at init time.  <a href="#aecac2eda8f41ca90e6db587e3ce40a0d">More...</a><br /></td></tr>
<tr class="separator:aecac2eda8f41ca90e6db587e3ce40a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b91c1f5904e52a807a38a8555ebdf"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a8f2b91c1f5904e52a807a38a8555ebdf">special_init</a> )(struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, void *<a class="el" href="structavr__t.html#abe222f6d3581e7920dcad5306cc906a8">data</a>)</td></tr>
<tr class="memdesc:a8f2b91c1f5904e52a807a38a8555ebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">called at init time (for special purposes like using a memory mapped file as flash see: simduino)  <a href="#a8f2b91c1f5904e52a807a38a8555ebdf">More...</a><br /></td></tr>
<tr class="separator:a8f2b91c1f5904e52a807a38a8555ebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114e074647b0e73ccbaa21557accfc2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a0114e074647b0e73ccbaa21557accfc2">special_deinit</a> )(struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, void *<a class="el" href="structavr__t.html#abe222f6d3581e7920dcad5306cc906a8">data</a>)</td></tr>
<tr class="memdesc:a0114e074647b0e73ccbaa21557accfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">called at termination time ( to clean special initializations)  <a href="#a0114e074647b0e73ccbaa21557accfc2">More...</a><br /></td></tr>
<tr class="separator:a0114e074647b0e73ccbaa21557accfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7a9d1468bc49001836107c496f8818"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#aaa7a9d1468bc49001836107c496f8818">special_data</a></td></tr>
<tr class="memdesc:aaa7a9d1468bc49001836107c496f8818"><td class="mdescLeft">&#160;</td><td class="mdescRight">value passed to <a class="el" href="structavr__t.html#a8f2b91c1f5904e52a807a38a8555ebdf" title="called at init time (for special purposes like using a memory mapped file as flash see: simduino) ...">special_init()</a> and <a class="el" href="structavr__t.html#a0114e074647b0e73ccbaa21557accfc2" title="called at termination time ( to clean special initializations) ">special_deinit()</a>  <a href="#aaa7a9d1468bc49001836107c496f8818">More...</a><br /></td></tr>
<tr class="separator:aaa7a9d1468bc49001836107c496f8818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8205394eb2ea5b58a1f5e44a1f204f97"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a8205394eb2ea5b58a1f5e44a1f204f97">reset</a> )(struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>)</td></tr>
<tr class="memdesc:a8205394eb2ea5b58a1f5e44a1f204f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">called at reset time  <a href="#a8205394eb2ea5b58a1f5e44a1f204f97">More...</a><br /></td></tr>
<tr class="separator:a8205394eb2ea5b58a1f5e44a1f204f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9ea88cae2b6b6a7995d6f0ccbea28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr.html#ga984d64ad544680c56b531ecbc04997c2">avr_run_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a1fb9ea88cae2b6b6a7995d6f0ccbea28">run</a></td></tr>
<tr class="memdesc:a1fb9ea88cae2b6b6a7995d6f0ccbea28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default AVR core run function.  <a href="#a1fb9ea88cae2b6b6a7995d6f0ccbea28">More...</a><br /></td></tr>
<tr class="separator:a1fb9ea88cae2b6b6a7995d6f0ccbea28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4ec2eefe5fe55ac955fed5e42e7a52"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a5c4ec2eefe5fe55ac955fed5e42e7a52">sleep</a> )(struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, <a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a> howLong)</td></tr>
<tr class="memdesc:a5c4ec2eefe5fe55ac955fed5e42e7a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep default behaviour.  <a href="#a5c4ec2eefe5fe55ac955fed5e42e7a52">More...</a><br /></td></tr>
<tr class="separator:a5c4ec2eefe5fe55ac955fed5e42e7a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3666777d7e34c4779e0988dfca22dbd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structavr__irq__pool__t.html">avr_irq_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a3666777d7e34c4779e0988dfca22dbd2">irq_pool</a></td></tr>
<tr class="memdesc:a3666777d7e34c4779e0988dfca22dbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every IRQs will be stored in this pool.  <a href="#a3666777d7e34c4779e0988dfca22dbd2">More...</a><br /></td></tr>
<tr class="separator:a3666777d7e34c4779e0988dfca22dbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af366c358080911dc8619f2955e683bee"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#af366c358080911dc8619f2955e683bee">sreg</a> [8]</td></tr>
<tr class="memdesc:af366c358080911dc8619f2955e683bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirror of the SREG register, to facilitate the access to bits in the opcode decoder.  <a href="#af366c358080911dc8619f2955e683bee">More...</a><br /></td></tr>
<tr class="separator:af366c358080911dc8619f2955e683bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e28308c4b751693b963879ddd1ac9b2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a9e28308c4b751693b963879ddd1ac9b2">interrupt_state</a></td></tr>
<tr class="memdesc:a9e28308c4b751693b963879ddd1ac9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt state: 00: idle (no wait, no pending interrupts) or disabled &lt;0: wait till zero &gt;0: interrupt pending.  <a href="#a9e28308c4b751693b963879ddd1ac9b2">More...</a><br /></td></tr>
<tr class="separator:a9e28308c4b751693b963879ddd1ac9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851045383751320cd25e5bd233a333f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sim__avr.html#gae37c87fbdd9762d724e4d5748572ab75">avr_flashaddr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#af851045383751320cd25e5bd233a333f">pc</a></td></tr>
<tr class="memdesc:af851045383751320cd25e5bd233a333f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current PC Note that the PC is representing /bytes/ while the AVR value is assumed to be "words".  <a href="#af851045383751320cd25e5bd233a333f">More...</a><br /></td></tr>
<tr class="separator:af851045383751320cd25e5bd233a333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe0fd20eb0ec7a9aadcc1ef0575a46c"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a6f464f62d3d6ed8c74f038751a3f5e3c"><td class="memItemLeft" >&#160;&#160;&#160;struct <a class="el" href="structavr__irq__t.html">avr_irq_t</a> *&#160;&#160;&#160;<a class="el" href="structavr__t.html#a6f464f62d3d6ed8c74f038751a3f5e3c">irq</a></td></tr>
<tr class="memdesc:a6f464f62d3d6ed8c74f038751a3f5e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional, used only if asked for with <a class="el" href="group__sim__io.html#ga57ef8d43a30075c976601bbc5bec9a79" title="Get the IRQ for an absolute IO address. ">avr_iomem_getirq()</a>  <a href="#a6f464f62d3d6ed8c74f038751a3f5e3c">More...</a><br /></td></tr>
<tr class="separator:a6f464f62d3d6ed8c74f038751a3f5e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af078899279ff54389d8de895855d9563"><td class="memItemLeft" >&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a13623f1d68513495c21f8b061b1a5aec"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;void *&#160;&#160;&#160;<a class="el" href="structavr__t.html#a13623f1d68513495c21f8b061b1a5aec">param</a></td></tr>
<tr class="separator:a13623f1d68513495c21f8b061b1a5aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e0766aaedeb11983566141bdfcf3c"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="group__sim__avr.html#ga4cc60c0d269899b7c7139c02eabade90">avr_io_read_t</a>&#160;&#160;&#160;<a class="el" href="structavr__t.html#a6f2e0766aaedeb11983566141bdfcf3c">c</a></td></tr>
<tr class="separator:a6f2e0766aaedeb11983566141bdfcf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af078899279ff54389d8de895855d9563"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<a class="el" href="structavr__t.html#af078899279ff54389d8de895855d9563">r</a></td></tr>
<tr class="separator:af078899279ff54389d8de895855d9563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba78cc5cb8e9ec89323235c344ed73"><td class="memItemLeft" >&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a13623f1d68513495c21f8b061b1a5aec"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;void *&#160;&#160;&#160;<a class="el" href="structavr__t.html#a13623f1d68513495c21f8b061b1a5aec">param</a></td></tr>
<tr class="separator:a13623f1d68513495c21f8b061b1a5aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5451b2c77fde01f67683e57fafa905"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="group__sim__avr.html#gaa52956f25dc73da682ad85e1e2cdddac">avr_io_write_t</a>&#160;&#160;&#160;<a class="el" href="structavr__t.html#abb5451b2c77fde01f67683e57fafa905">c</a></td></tr>
<tr class="separator:abb5451b2c77fde01f67683e57fafa905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba78cc5cb8e9ec89323235c344ed73"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<a class="el" href="structavr__t.html#ad4ba78cc5cb8e9ec89323235c344ed73">w</a></td></tr>
<tr class="separator:ad4ba78cc5cb8e9ec89323235c344ed73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe0fd20eb0ec7a9aadcc1ef0575a46c"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a8fe0fd20eb0ec7a9aadcc1ef0575a46c">io</a> [<a class="el" href="group__sim__avr.html#ggaaf8fd5f0e57d456151c951e0f3715fc4a273926544f58620540a274fc8acc3aab">MAX_IOs</a>]</td></tr>
<tr class="memdesc:a8fe0fd20eb0ec7a9aadcc1ef0575a46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback when specific IO registers are read/written.  <a href="#a8fe0fd20eb0ec7a9aadcc1ef0575a46c">More...</a><br /></td></tr>
<tr class="separator:a8fe0fd20eb0ec7a9aadcc1ef0575a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76c97c8de275cea5c165037d714da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#acd76c97c8de275cea5c165037d714da0">io_shared_io_count</a></td></tr>
<tr class="memdesc:acd76c97c8de275cea5c165037d714da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This block allows sharing of the IO write/read on addresses between multiple callbacks.  <a href="#acd76c97c8de275cea5c165037d714da0">More...</a><br /></td></tr>
<tr class="separator:acd76c97c8de275cea5c165037d714da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced67597209fa6886a7bb2f9b8ca8b76"><td class="memItemLeft" >struct {</td></tr>
<tr class="memitem:a5810b6407672b8e7aeba609b4bb649de"><td class="memItemLeft" >&#160;&#160;&#160;int&#160;&#160;&#160;<a class="el" href="structavr__t.html#a5810b6407672b8e7aeba609b4bb649de">used</a></td></tr>
<tr class="separator:a5810b6407672b8e7aeba609b4bb649de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5049ee7ed9ca6e112b081ee398b33a"><td class="memItemLeft" >&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a13623f1d68513495c21f8b061b1a5aec"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;void *&#160;&#160;&#160;<a class="el" href="structavr__t.html#a13623f1d68513495c21f8b061b1a5aec">param</a></td></tr>
<tr class="separator:a13623f1d68513495c21f8b061b1a5aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e9d676e64eaa6c9a298aeb5623491"><td class="memItemLeft" >&#160;&#160;&#160;&#160;&#160;&#160;void *&#160;&#160;&#160;<a class="el" href="structavr__t.html#a9d2e9d676e64eaa6c9a298aeb5623491">c</a></td></tr>
<tr class="separator:a9d2e9d676e64eaa6c9a298aeb5623491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5049ee7ed9ca6e112b081ee398b33a"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<a class="el" href="structavr__t.html#a3a5049ee7ed9ca6e112b081ee398b33a">io</a> [4]</td></tr>
<tr class="separator:a3a5049ee7ed9ca6e112b081ee398b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced67597209fa6886a7bb2f9b8ca8b76"><td class="memItemLeft" valign="top">}&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#aced67597209fa6886a7bb2f9b8ca8b76">io_shared_io</a> [4]</td></tr>
<tr class="separator:aced67597209fa6886a7bb2f9b8ca8b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0894a13228760b648a13d34f188fa69"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#af0894a13228760b648a13d34f188fa69">flash</a></td></tr>
<tr class="memdesc:af0894a13228760b648a13d34f188fa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash memory (initialized to 0xff, and code loaded into it)  <a href="#af0894a13228760b648a13d34f188fa69">More...</a><br /></td></tr>
<tr class="separator:af0894a13228760b648a13d34f188fa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe222f6d3581e7920dcad5306cc906a8"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#abe222f6d3581e7920dcad5306cc906a8">data</a></td></tr>
<tr class="memdesc:abe222f6d3581e7920dcad5306cc906a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SRAM memory, starting by the general purpose registers, and IO registers.  <a href="#abe222f6d3581e7920dcad5306cc906a8">More...</a><br /></td></tr>
<tr class="separator:abe222f6d3581e7920dcad5306cc906a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da78f9f88bc396fe312b427a02fc64a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structavr__io__t.html">avr_io_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a8da78f9f88bc396fe312b427a02fc64a">io_port</a></td></tr>
<tr class="memdesc:a8da78f9f88bc396fe312b427a02fc64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue of io modules.  <a href="#a8da78f9f88bc396fe312b427a02fc64a">More...</a><br /></td></tr>
<tr class="separator:a8da78f9f88bc396fe312b427a02fc64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a4a9fbb5ee71cbb6edcc6a678db06e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structavr__cycle__timer__pool__t.html">avr_cycle_timer_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a60a4a9fbb5ee71cbb6edcc6a678db06e">cycle_timers</a></td></tr>
<tr class="memdesc:a60a4a9fbb5ee71cbb6edcc6a678db06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycle timers tracking &amp; delivery.  <a href="#a60a4a9fbb5ee71cbb6edcc6a678db06e">More...</a><br /></td></tr>
<tr class="separator:a60a4a9fbb5ee71cbb6edcc6a678db06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ea0bf8730c37905739969e40a503cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structavr__int__table__t.html">avr_int_table_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a99ea0bf8730c37905739969e40a503cd">interrupts</a></td></tr>
<tr class="memdesc:a99ea0bf8730c37905739969e40a503cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt vectors and delivery fifo.  <a href="#a99ea0bf8730c37905739969e40a503cd">More...</a><br /></td></tr>
<tr class="separator:a99ea0bf8730c37905739969e40a503cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6890d7b635be27ecf740d938ff5379de"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a6890d7b635be27ecf740d938ff5379de">trace</a>:1</td></tr>
<tr class="memdesc:a6890d7b635be27ecf740d938ff5379de"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEBUG ONLY &ndash; value ignored if CONFIG_SIMAVR_TRACE = 0.  <a href="#a6890d7b635be27ecf740d938ff5379de">More...</a><br /></td></tr>
<tr class="separator:a6890d7b635be27ecf740d938ff5379de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae001c74b249ea53b90cc573c1ca7699b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#ae001c74b249ea53b90cc573c1ca7699b">log</a>:2</td></tr>
<tr class="memdesc:ae001c74b249ea53b90cc573c1ca7699b"><td class="mdescLeft">&#160;</td><td class="mdescRight">log level, default to 1  <a href="#ae001c74b249ea53b90cc573c1ca7699b">More...</a><br /></td></tr>
<tr class="separator:ae001c74b249ea53b90cc573c1ca7699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6528512702cce43808257bae4797b534"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structavr__trace__data__t.html">avr_trace_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a6528512702cce43808257bae4797b534">trace_data</a></td></tr>
<tr class="memdesc:a6528512702cce43808257bae4797b534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used if CONFIG_SIMAVR_TRACE is defined.  <a href="#a6528512702cce43808257bae4797b534">More...</a><br /></td></tr>
<tr class="separator:a6528512702cce43808257bae4797b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdfcfa047910ac8ea76b09f7b8f41aa"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structavr__vcd__t.html">avr_vcd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#a1bdfcfa047910ac8ea76b09f7b8f41aa">vcd</a></td></tr>
<tr class="memdesc:a1bdfcfa047910ac8ea76b09f7b8f41aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value Change Dump file (waveforms) This is the VCD file that gets allocated if the firmware that is loaded explicitly asks for a trace to be generated, and allocates it's own symbols using AVR_MMCU_TAG_VCD_TRACE (see <a class="el" href="avr__mcu__section_8h.html">avr_mcu_section.h</a>)  <a href="#a1bdfcfa047910ac8ea76b09f7b8f41aa">More...</a><br /></td></tr>
<tr class="separator:a1bdfcfa047910ac8ea76b09f7b8f41aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa847deb23933a96bcf8399c301e8c74c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structavr__gdb__t.html">avr_gdb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#aa847deb23933a96bcf8399c301e8c74c">gdb</a></td></tr>
<tr class="memdesc:aa847deb23933a96bcf8399c301e8c74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gdb hooking structure. Only present when gdb server is active  <a href="#aa847deb23933a96bcf8399c301e8c74c">More...</a><br /></td></tr>
<tr class="separator:aa847deb23933a96bcf8399c301e8c74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac257d73d7f8358c6c22b5f398511369f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr__t.html#ac257d73d7f8358c6c22b5f398511369f">gdb_port</a></td></tr>
<tr class="memdesc:ac257d73d7f8358c6c22b5f398511369f"><td class="mdescLeft">&#160;</td><td class="mdescRight">if non-zero, the gdb server will be started when the core crashed even if not activated at startup if zero, the simulator will just exit() in case of a crash  <a href="#ac257d73d7f8358c6c22b5f398511369f">More...</a><br /></td></tr>
<tr class="separator:ac257d73d7f8358c6c22b5f398511369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main AVR instance. </p>
<p>Some of these fields are set by the AVR "Core" definition files the rest is runtime data (as little as possible) </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="adf95d9fb3a2bf2c9e7c08fce4321e3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t address_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2, or 3 for cores &gt;128KB in flash </p>

</div>
</div>
<a class="anchor" id="adeb62932b1bf8d286a3df060f408ddf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t aref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(optional) voltages in millivolts </p>

</div>
</div>
<a class="anchor" id="a5be3f1be5552951cd6c9d8215216e220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t avcc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f2e0766aaedeb11983566141bdfcf3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr.html#ga4cc60c0d269899b7c7139c02eabade90">avr_io_read_t</a> c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb5451b2c77fde01f67683e57fafa905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr.html#gaa52956f25dc73da682ad85e1e2cdddac">avr_io_write_t</a> c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d2e9d676e64eaa6c9a298aeb5623491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e53f0a463305b7b6ef22813a60bcf98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t codeend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>filled by the ELF data, this allow tracking of invalid jumps </p>

</div>
</div>
<a class="anchor" id="aa50999c398e8eb00dcc9356cbe97dd35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a> cycle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>current cycle </p>

</div>
</div>
<a class="anchor" id="a60a4a9fbb5ee71cbb6edcc6a678db06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structavr__cycle__timer__pool__t.html">avr_cycle_timer_pool_t</a> cycle_timers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycle timers tracking &amp; delivery. </p>

</div>
</div>
<a class="anchor" id="abe222f6d3581e7920dcad5306cc906a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SRAM memory, starting by the general purpose registers, and IO registers. </p>

</div>
</div>
<a class="anchor" id="a0aa39ad552c1ecaedab1c682a46bd060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t e2end</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6fce2154767008ee2a6f9494b9e53b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr__types.html#ga3b13b10386fba02e9279995b1a7e103f">avr_io_addr_t</a> eind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optional, only for EIJMP/EICALL on &gt;64Kb cores </p>

</div>
</div>
<a class="anchor" id="af0894a13228760b648a13d34f188fa69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* flash</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash memory (initialized to 0xff, and code loaded into it) </p>

</div>
</div>
<a class="anchor" id="a3ea10c774417c9658250256327874273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t flashend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab632fb0b4d5156ea4df0b1e15410e913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t frequency</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frequency we are running at </p>

</div>
</div>
<a class="anchor" id="a18a6852737616d49536eb37c388d5c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fuse[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa847deb23933a96bcf8399c301e8c74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structavr__gdb__t.html">avr_gdb_t</a>* gdb</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gdb hooking structure. Only present when gdb server is active </p>

</div>
</div>
<a class="anchor" id="ac257d73d7f8358c6c22b5f398511369f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gdb_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if non-zero, the gdb server will be started when the core crashed even if not activated at startup if zero, the simulator will just exit() in case of a crash </p>

</div>
</div>
<a class="anchor" id="aecac2eda8f41ca90e6db587e3ce40a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* init) (struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called at init time. </p>

</div>
</div>
<a class="anchor" id="a9e28308c4b751693b963879ddd1ac9b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t interrupt_state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt state: 00: idle (no wait, no pending interrupts) or disabled &lt;0: wait till zero &gt;0: interrupt pending. </p>
<p>interrupt state </p>

</div>
</div>
<a class="anchor" id="a99ea0bf8730c37905739969e40a503cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structavr__int__table__t.html">avr_int_table_t</a> interrupts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt vectors and delivery fifo. </p>

</div>
</div>
<a class="anchor" id="a8fe0fd20eb0ec7a9aadcc1ef0575a46c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   io[<a class="el" href="group__sim__avr.html#ggaaf8fd5f0e57d456151c951e0f3715fc4a273926544f58620540a274fc8acc3aab">MAX_IOs</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback when specific IO registers are read/written. </p>
<p>There is one drawback here, there is in way of knowing what is the "beginning of useful sram" on a core, so there is no way to deduce what is the maximum IO register for a core, and thus, we can't allocate this table dynamically. If you wanted to emulate the BIG AVRs, and XMegas, this would need work. </p>

</div>
</div>
<a class="anchor" id="a3a5049ee7ed9ca6e112b081ee398b33a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   io[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da78f9f88bc396fe312b427a02fc64a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structavr__io__t.html">avr_io_t</a>* io_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue of io modules. </p>

</div>
</div>
<a class="anchor" id="aced67597209fa6886a7bb2f9b8ca8b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   io_shared_io[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd76c97c8de275cea5c165037d714da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int io_shared_io_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This block allows sharing of the IO write/read on addresses between multiple callbacks. </p>
<p>In 99% of case it's not needed, however on the tiny* (tiny85 at last) some registers have bits that are used by different IO modules. If this case is detected, a special "dispatch" callback is installed that will handle this particular case, without impacting the performance of the other, normal cases... </p>

</div>
</div>
<a class="anchor" id="a6f464f62d3d6ed8c74f038751a3f5e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structavr__irq__t.html">avr_irq_t</a>* irq</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optional, used only if asked for with <a class="el" href="group__sim__io.html#ga57ef8d43a30075c976601bbc5bec9a79" title="Get the IRQ for an absolute IO address. ">avr_iomem_getirq()</a> </p>

</div>
</div>
<a class="anchor" id="a3666777d7e34c4779e0988dfca22dbd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structavr__irq__pool__t.html">avr_irq_pool_t</a> irq_pool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every IRQs will be stored in this pool. </p>
<p>It is not mandatory (yet) but will allow listing IRQs and their connections </p>

</div>
</div>
<a class="anchor" id="ae001c74b249ea53b90cc573c1ca7699b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t log</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>log level, default to 1 </p>

</div>
</div>
<a class="anchor" id="ab64a3ef25ab524ce24d8a522759946da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mmcu</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>name of the AVR </p>

</div>
</div>
<a class="anchor" id="a13623f1d68513495c21f8b061b1a5aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* param</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af851045383751320cd25e5bd233a333f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr.html#gae37c87fbdd9762d724e4d5748572ab75">avr_flashaddr_t</a> pc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current PC Note that the PC is representing /bytes/ while the AVR value is assumed to be "words". </p>
<p>This is in line with what GDB does... this is why you will see &gt;&gt;1 and &lt;&lt;1 in the decoder to handle jumps. It CAN be a little confusing, so concentrate, young grasshopper. </p>

</div>
</div>
<a class="anchor" id="af078899279ff54389d8de895855d9563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   r</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87a4791269dfe22d393f282e523e8742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ramend</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a14704e421137047a3df0676ef7fabb36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr__types.html#ga3b13b10386fba02e9279995b1a7e103f">avr_io_addr_t</a> rampz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optional, only for ELPM/SPM on &gt;64Kb cores </p>

</div>
</div>
<a class="anchor" id="a8205394eb2ea5b58a1f5e44a1f204f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* reset) (struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>called at reset time </p>

</div>
</div>
<a class="anchor" id="a1fb9ea88cae2b6b6a7995d6f0ccbea28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr.html#ga984d64ad544680c56b531ecbc04997c2">avr_run_t</a> run</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default AVR core run function. </p>
<p>Two modes are available, a "raw" run that goes as fast as it can, and a "gdb" mode that also watchouts for gdb events and is a little bit slower. </p>

</div>
</div>
<a class="anchor" id="ac2defa34e1d57649feca9e277570adc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a> run_cycle_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cycles to run before next timer </p>

</div>
</div>
<a class="anchor" id="a50b68f6669dd3b7e33dc365cfae5f100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a> run_cycle_limit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum run cycle interval limit </p>

</div>
</div>
<a class="anchor" id="a28beecf564ea81ebea2eee4f6c97ad93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t signature[3]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c4ec2eefe5fe55ac955fed5e42e7a52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* sleep) (struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, <a class="el" href="group__sim__avr__types.html#ga76bf9c3566780a2caf7ddc56c6c6f0d8">avr_cycle_count_t</a> howLong)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep default behaviour. </p>
<p>In "raw" mode, it calls usleep, in gdb mode, it waits for howLong for gdb command on it's sockets. </p>

</div>
</div>
<a class="anchor" id="a2eee3ccdb7463c4aaa6fa3e53fa40c29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sleep_usec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep requests are accumulated in sleep_usec until the minimum sleep value is reached, at which point sleep_usec is cleared and the sleep request is passed on to the operating system. </p>

</div>
</div>
<a class="anchor" id="aaa7a9d1468bc49001836107c496f8818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* special_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>value passed to <a class="el" href="structavr__t.html#a8f2b91c1f5904e52a807a38a8555ebdf" title="called at init time (for special purposes like using a memory mapped file as flash see: simduino) ...">special_init()</a> and <a class="el" href="structavr__t.html#a0114e074647b0e73ccbaa21557accfc2" title="called at termination time ( to clean special initializations) ">special_deinit()</a> </p>

</div>
</div>
<a class="anchor" id="a0114e074647b0e73ccbaa21557accfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* special_deinit) (struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, void *<a class="el" href="structavr__t.html#abe222f6d3581e7920dcad5306cc906a8">data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>called at termination time ( to clean special initializations) </p>

</div>
</div>
<a class="anchor" id="a8f2b91c1f5904e52a807a38a8555ebdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* special_init) (struct <a class="el" href="structavr__t.html">avr_t</a> *<a class="el" href="run__avr_8c.html#aeb0aa2edcda5f05d05ae8eaada1ce660">avr</a>, void *<a class="el" href="structavr__t.html#abe222f6d3581e7920dcad5306cc906a8">data</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>called at init time (for special purposes like using a memory mapped file as flash see: simduino) </p>

</div>
</div>
<a class="anchor" id="af366c358080911dc8619f2955e683bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t sreg[8]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mirror of the SREG register, to facilitate the access to bits in the opcode decoder. </p>
<p>This array is re-synthesized back/forth when SREG changes </p>

</div>
</div>
<a class="anchor" id="a89f234133d3efe315836311cbf21c64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int state</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stopped, running, sleeping </p>

</div>
</div>
<a class="anchor" id="a6890d7b635be27ecf740d938ff5379de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t trace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEBUG ONLY &ndash; value ignored if CONFIG_SIMAVR_TRACE = 0. </p>

</div>
</div>
<a class="anchor" id="a6528512702cce43808257bae4797b534"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structavr__trace__data__t.html">avr_trace_data_t</a>* trace_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used if CONFIG_SIMAVR_TRACE is defined. </p>

</div>
</div>
<a class="anchor" id="a5810b6407672b8e7aeba609b4bb649de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int used</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a35cfa22b2140b109fe24b97c42d5a5ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vcc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1bdfcfa047910ac8ea76b09f7b8f41aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structavr__vcd__t.html">avr_vcd_t</a>* vcd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value Change Dump file (waveforms) This is the VCD file that gets allocated if the firmware that is loaded explicitly asks for a trace to be generated, and allocates it's own symbols using AVR_MMCU_TAG_VCD_TRACE (see <a class="el" href="avr__mcu__section_8h.html">avr_mcu_section.h</a>) </p>

</div>
</div>
<a class="anchor" id="a62bdc8c5972b025d3ad733df81f3167d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t vector_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4ba78cc5cb8e9ec89323235c344ed73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct { ... }   w</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>simavr/include/<a class="el" href="sim__avr_8h_source.html">sim_avr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structavr__t.html">avr_t</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
